[{"D:\\testing\\markov-music\\src\\index.tsx":"1","D:\\testing\\markov-music\\src\\App.tsx":"2","D:\\testing\\markov-music\\src\\musicGen.ts":"3","D:\\testing\\markov-music\\src\\parseMidi.ts":"4","D:\\testing\\markov-music\\src\\components\\SelectSong.tsx":"5","D:\\testing\\markov-music\\src\\components\\Info.tsx":"6","D:\\testing\\markov-music\\src\\stats.tsx":"7"},{"size":660,"mtime":1607579453014,"results":"8","hashOfConfig":"9"},{"size":417,"mtime":1607551644649,"results":"10","hashOfConfig":"9"},{"size":3498,"mtime":1607579449237,"results":"11","hashOfConfig":"9"},{"size":1771,"mtime":1607585319389,"results":"12","hashOfConfig":"9"},{"size":5726,"mtime":1607586437643,"results":"13","hashOfConfig":"9"},{"size":3159,"mtime":1607580707910,"results":"14","hashOfConfig":"9"},{"size":1951,"mtime":1607564297579,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"d570za",{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"20"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"D:\\testing\\markov-music\\src\\index.tsx",[],"D:\\testing\\markov-music\\src\\App.tsx",[],["32","33"],"D:\\testing\\markov-music\\src\\musicGen.ts",["34"],"//@ts-ignore\r\nimport Chain from 'markov-chains';\r\nimport * as Tone from \"tone\";\r\nimport {\r\n    parseMidi,\r\n    Song\r\n} from \"./parseMidi\"\r\nimport {\r\n    NoteJSON\r\n} from '@tonejs/midi/dist/Note';\r\nimport {\r\n    Sampler\r\n} from 'tone';\r\n\r\nconst COMMA = ',';\r\n\r\nexport const genMusic = async () => {\r\n    Tone.setContext(new Tone.Context({ latencyHint : \"interactive\" }))\r\n    const song = await parseMidi(\"\");\r\n    const parsedNotes = quantizeNotes(song)\r\n    playNotes(parsedNotes, song)\r\n}\r\n\r\nfunction quantizeNotes(song: Song) {\r\n    const notes: NoteJSON[] = song.tracks[0].notes;\r\n    if (song.tracks[1]) {\r\n        notes.push.apply(notes, song.tracks[1].notes);\r\n    }\r\n\r\n    const quantizedNotes = [];\r\n\r\n    for (let i = 0; i <= song.length; i += song.noteInterval) {\r\n        const names = notes.filter(\r\n                note => i <= note.time && note.time < i + song.noteInterval\r\n            ).map(({ name }) => name)\r\n            .sort();\r\n\r\n        quantizedNotes.push(names.join(COMMA));\r\n    }\r\n\r\n    const phrases = [];\r\n\r\n    const enCopy = quantizedNotes.slice(0);\r\n    while (enCopy.length > 0) {\r\n        phrases.push(enCopy.splice(0, song.phraseLength));\r\n    }\r\n\r\n    const phrasesIndexed = phrases.map(phrase =>\r\n        phrase.map((names, i) =>\r\n            names.length === 0 ? `${i}` : `${i}${COMMA}${names}`\r\n        )\r\n    );\r\n\r\n    return phrasesIndexed;\r\n}\r\n\r\nlet sampler:Sampler;\r\n\r\nconst buildPhrase = (parsedNotes: string[][], song: Song) => {\r\n    const chain = new Chain(parsedNotes);\r\n    let totalWaitTime = 0;\r\n    let tempWaitTime = 0;\r\n    while (totalWaitTime <= song.length) {\r\n        var walker = chain.walk();\r\n        walker.forEach((noteName: String) => {\r\n            const [t, ...names] = noteName.split(COMMA);\r\n            const parsedT = Number.parseInt(t, 10);\r\n            names.forEach(name => {\r\n                const waitTime = parsedT * song.noteInterval + totalWaitTime;\r\n                tempWaitTime = waitTime;\r\n                sampler.triggerAttack(\r\n                    name,\r\n                    `+${waitTime+1+Math.random()*0.05-0.025}`\r\n                )\r\n            });\r\n        });\r\n\r\n        totalWaitTime = tempWaitTime + song.noteInterval + 1;\r\n    }\r\n}\r\n\r\nlet phraseBuilder = () => {};\r\n\r\nfunction playNotes(parsedNotes: string[][], song: Song) {\r\n    Tone.Transport.PPQ = song.ppq;\r\n    if (sampler) {\r\n        stopPlaying();\r\n    }\r\n    sampler = new Tone.Sampler({\r\n            urls: {\r\n                \"C1\": \"C1.mp3\",\r\n                \"C4\": \"C4.mp3\",\r\n                \"C6\": \"C6.mp3\",\r\n                \"D#1\": \"Ds1.mp3\",\r\n                \"D#4\": \"Ds4.mp3\",\r\n                \"D#6\": \"Ds6.mp3\",\r\n                \"F#1\": \"Fs1.mp3\",\r\n                \"F#4\": \"Fs4.mp3\",\r\n                \"F#6\": \"Fs6.mp3\",\r\n                \"A1\": \"A1.mp3\",\r\n                \"A4\": \"A4.mp3\",\r\n                \"A6\": \"A6.mp3\"\r\n            },\r\n            release: 1,\r\n            baseUrl: \"https://tonejs.github.io/audio/salamander/\",\r\n        });\r\n    sampler.volume.value = -10;\r\n    sampler.toDestination();\r\n\r\n    phraseBuilder = () => buildPhrase(parsedNotes, song);\r\n\r\n    Tone.loaded().then(() => {\r\n        Tone.Transport.scheduleOnce(\r\n            phraseBuilder,\r\n            song.phraseLength * song.noteInterval\r\n        )\r\n\r\n        Tone.Transport.start(\"+0.1\");\r\n        Tone.start();\r\n    })\r\n}\r\n\r\nexport function stopPlaying() {\r\n    Tone.Transport.cancel();\r\n    Tone.Transport.stop();\r\n    sampler.dispose();\r\n}\r\n\r\nexport default genMusic;","D:\\testing\\markov-music\\src\\parseMidi.ts",[],"D:\\testing\\markov-music\\src\\components\\SelectSong.tsx",["35","36"],"D:\\testing\\markov-music\\src\\components\\Info.tsx",[],"D:\\testing\\markov-music\\src\\stats.tsx",[],{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","replacedBy":"40"},{"ruleId":"41","severity":1,"message":"42","line":65,"column":24,"nodeType":"43","messageId":"44","endLine":76,"endColumn":10},{"ruleId":"45","severity":1,"message":"46","line":157,"column":17,"nodeType":"47","endLine":157,"endColumn":96},{"ruleId":"45","severity":1,"message":"46","line":158,"column":17,"nodeType":"47","endLine":158,"endColumn":99},"no-native-reassign",["48"],"no-negated-in-lhs",["49"],"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'totalWaitTime', 'tempWaitTime', 'sampler'.","ArrowFunctionExpression","unsafeRefs","jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","no-global-assign","no-unsafe-negation"]